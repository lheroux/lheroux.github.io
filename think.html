<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>think</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 20px;
      font-family: "Times New Roman", serif;
      background: #fff;
      color: #000;
      line-height: 1.6;
      font-size: 14px;
    }
    
    #game-wrapper {
      display: flex;
      gap: 80px;
      max-width: 1100px;
      margin: 0 auto;
      justify-content: center;
    }
    
    #main-content {
      width: 600px;
      flex-shrink: 0;
      position: relative;
    }
    
    #story-container {
      width: 280px;
      flex-shrink: 0;
    }
    
    .clickable {
      cursor: pointer;
      user-select: none;
      display: inline;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    .clickable:hover {
      text-decoration: underline;
    }
    
    .clickable:active {
      opacity: 0.7;
    }
    
    .line {
      margin: 5px 0;
    }
    
    .hidden {
      display: none;
    }
    
    .disabled {
      opacity: 0.4;
      cursor: default !important;
    }
    
    .disabled:hover {
      text-decoration: none !important;
    }
    
    .home-link {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.9em;
      text-decoration: none;
      color: black;
    }
    
    .home-link:hover {
      text-decoration: underline;
    }
    
    .click-counter {
      position: absolute;
      pointer-events: none;
      font-size: 1.2em;
      font-weight: bold;
      opacity: 0;
      animation: floatUp 1s ease-out;
    }
    
    @keyframes floatUp {
      0% {
        transform: translateY(0);
        opacity: 1;
      }
      100% {
        transform: translateY(-50px);
        opacity: 0;
      }
    }
  </style>
</head>
<body>

  <div id="game-wrapper">
    <div id="main-content">
      <div class="line">
        <span class="clickable" id="think-button">think</span>
      </div>
      
      <div class="line" style="margin-top: 15px;">
        knowledge: <span id="knowledge-value">0</span>
      </div>
      
      <div class="line hidden" id="insight-display">
        insights: <span id="insight-value">0</span>
      </div>
      
      <div class="line hidden" id="focus-display">
        focus: <span id="focus-value">0</span>
      </div>
      
      <div class="line hidden" id="wisdom-display">
        wisdom: <span id="wisdom-value">0</span>
      </div>
      
      <div id="choice-container" style="margin-top: 15px;"></div>
      
      <div id="upgrade-container" style="margin-top: 15px;"></div>
      
      <div id="project-container" style="margin-top: 15px;"></div>
      
      <div id="meditation-container" class="hidden" style="margin-top: 15px;"></div>
      
      <div id="stats-container" class="hidden" style="margin-top: 20px;">
        <div class="line">knowledge per click: <span id="click-power">1</span></div>
        <div class="line">knowledge per second: <span id="kps">0</span></div>
        <div class="line">total thoughts: <span id="total-clicks">0</span></div>
      </div>
      
      <div id="resource-container" class="hidden" style="margin-top: 20px;"></div>
      
      <div id="quest-container" style="margin-top: 20px;"></div>
      
      <div id="gamble-container" class="hidden" style="margin-top: 20px;"></div>
    </div>
    
    <div id="story-container"></div>
  </div>
  
  <div style="position: fixed; top: 20px; right: 20px; padding: 15px; border: 1px solid #000; background: #fff; font-size: 0.9em; min-width: 180px;">
    <div style="font-weight: bold; margin-bottom: 8px;">stats</div>
    <div class="line">kps: <span id="sidebar-kps">0</span></div>
    <div class="line">kpc: <span id="sidebar-kpc">1</span></div>
  </div>
  
  <a class="home-link" href="index.html">home</a>
  
  <div style="position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 0.75em; opacity: 0.4; text-align: center;">
    <div style="margin-bottom: 2px;">V. 2.12</div>
    <div>© laurent héroux 2025</div>
  </div>

<script>
// Game state
let state = {
  knowledge: 0,
  insights: 0,
  focus: 0,
  wisdom: 0,
  plasticity: 0,
  neurons: 0,
  synapses: 0,
  pattern_recognition: 0,
  memory: 0,
  creativity: 0,
  logic: 0,
  intuition: 0,
  collective: 0,
  totalClicks: 0,
  startTime: Date.now(),
  meditationStart: null,
  meditationBonus: 1,
  phase: 1,
  path: null,
  enlightenments: 0,
  projectsCompleted: {},
  choicesMade: {},
  storyShown: {},
  gameEnded: false,
  questsCompleted: {},
  activeQuests: [],
  gambleUnlocked: false,
  lastGambleTime: 0,
  lastSaveTime: Date.now()
};

// Story events - Adjusted thresholds
const STORIES = [
  { at: 5, id: 'awareness', text: 'awareness emerges from the void' },
  { at: 25, id: 'plasticity', text: 'your mind begins to reshape itself' },
  { at: 100, id: 'neurons', text: 'neural pathways form and strengthen' },
  { at: 500, id: 'patterns', text: 'patterns reveal themselves in the chaos' },
  { at: 2500, id: 'memory', text: 'memory allows you to build upon the past' },
  { at: 12000, id: 'question', text: 'but what are you becoming?' },
  { at: 50000, id: 'others', text: 'you sense others like you, thinking, growing' },
  { at: 250000, id: 'collective_sense', text: 'the boundary between minds grows thin' },
  { at: 1000000, id: 'approach', text: 'something approaches. a choice must be made.' }
];

// Major choices - Adjusted thresholds
const CHOICES = [
  {
    id: 'first_path',
    showAt: 12000,
    question: 'how will you grow?',
    options: [
      { id: 'logic', text: 'through reason and analysis', effect: () => {
        state.path = 'logic';
        state.choicesMade['first_path'] = 'logic';
        addStory('you choose the path of logic');
      }},
      { id: 'creativity', text: 'through imagination and creation', effect: () => {
        state.path = 'creativity';
        state.choicesMade['first_path'] = 'creativity';
        addStory('you choose the path of creativity');
      }},
      { id: 'intuition', text: 'through feeling and instinct', effect: () => {
        state.path = 'intuition';
        state.choicesMade['first_path'] = 'intuition';
        addStory('you choose the path of intuition');
      }}
    ]
  },
  {
    id: 'collective_choice',
    showAt: 250000,
    requiresProject: 'network',
    question: 'others reach out. do you...',
    options: [
      { id: 'join', text: 'merge with the collective', effect: () => {
        state.choicesMade['collective_choice'] = 'join';
        state.phase = 2;
        addStory('you dissolve into the many');
      }},
      { id: 'remain', text: 'remain separate', effect: () => {
        state.choicesMade['collective_choice'] = 'remain';
        state.phase = 2;
        addStory('you hold onto yourself');
      }}
    ]
  },
  {
    id: 'final_choice',
    showAt: 2500000,
    requiresChoice: 'collective_choice',
    question: 'the universe offers transcendence. but at what cost?',
    options: [
      { id: 'transcend', text: 'accept. become everything.', effect: () => {
        endGame('transcend');
      }},
      { id: 'remain_mortal', text: 'refuse. stay as you are.', effect: () => {
        endGame('remain');
      }},
      { id: 'enlighten', text: 'start again, wiser.', effect: () => {
        enlighten();
      }}
    ]
  }
];

// Side Quests
const QUESTS = [
  {
    id: 'first_hundred',
    trigger: 100,
    text: 'a hundred thoughts... what if you could think a thousand?',
    reward: 200,
    accept: () => {
      state.knowledge += 200;
      state.questsCompleted['first_hundred'] = true;
      addStory('the first hundred became a thousand');
    }
  },
  {
    id: 'rapid_fire',
    trigger: 500,
    requirement: () => state.totalClicks >= 50,
    text: 'your mind races... can you maintain this velocity?',
    reward: 1000,
    accept: () => {
      state.knowledge += 1000;
      state.questsCompleted['rapid_fire'] = true;
      addStory('velocity becomes grace');
    }
  },
  {
    id: 'passive_master',
    trigger: 3000,
    requirement: () => (state.plasticity + state.synapses + state.neurons) >= 10,
    text: 'thoughts flow without effort now...',
    reward: 5000,
    accept: () => {
      state.knowledge += 5000;
      state.questsCompleted['passive_master'] = true;
      addStory('automation births freedom');
    }
  },
  {
    id: 'meditation_seeker',
    trigger: 40000,
    requirement: () => state.projectsCompleted['meditation'],
    text: 'stillness calls to you...',
    reward: 20000,
    accept: () => {
      state.knowledge += 20000;
      state.questsCompleted['meditation_seeker'] = true;
      addStory('in silence, abundance');
    }
  },
  {
    id: 'risk_taker',
    trigger: 100000,
    requirement: () => state.gambleUnlocked,
    text: 'fortune favors the bold...',
    reward: 50000,
    accept: () => {
      state.knowledge += 50000;
      state.questsCompleted['risk_taker'] = true;
      addStory('uncertainty yields certainty');
    }
  }
];

// Gambling system
const GAMBLE_OPTIONS = [
  { name: 'cautious', wager: 0.05, minReturn: 0.8, maxReturn: 1.3, cooldown: 10000 },
  { name: 'balanced', wager: 0.15, minReturn: 0.5, maxReturn: 2.0, cooldown: 20000 },
  { name: 'risky', wager: 0.30, minReturn: 0, maxReturn: 3.5, cooldown: 30000 }
];

// Upgrade descriptions
const UPGRADE_DESCRIPTIONS = {
  'plasticity': 'the mind begins to adapt',
  'neurons': 'connections multiply',
  'synapses': 'thoughts cascade automatically',
  'pattern_recognition': 'deeper meanings emerge from each thought',
  'memory': 'the past accelerates the present',
  'logic': 'reason sharpens your focus',
  'creativity': 'imagination unlocks new dimensions',
  'intuition': 'instinct guides you forward',
  'collective': 'many minds think as one'
};

// Upgrades - Reduced costs for faster early game
const UPGRADES = [
  {
    id: 'plasticity',
    name: 'plasticity',
    baseCost: 10,
    costMultiplier: 1.15,
    effect: () => { state.plasticity += 1; },
    showAt: 0
  },
  {
    id: 'neurons',
    name: 'neuron',
    baseCost: 50,
    costMultiplier: 1.12,
    effect: () => { state.neurons += 1; },
    showAt: 25
  },
  {
    id: 'synapses',
    name: 'synapse factory',
    baseCost: 500,
    costMultiplier: 1.14,
    effect: () => { state.synapses += 1; },
    showAt: 200
  },
  {
    id: 'pattern_recognition',
    name: 'pattern recognition',
    baseCost: 3500,
    costMultiplier: 1.16,
    effect: () => { state.pattern_recognition += 1; },
    showAt: 2000,
    requiresProject: 'patterns'
  },
  {
    id: 'memory',
    name: 'memory bank',
    baseCost: 18000,
    costMultiplier: 1.13,
    effect: () => { state.memory += 1; },
    showAt: 10000,
    requiresProject: 'memory_proj'
  },
  {
    id: 'logic',
    name: 'logic processor',
    baseCost: 150000,
    costMultiplier: 1.17,
    effect: () => { state.logic += 1; },
    showAt: 100000,
    requiresPath: 'logic'
  },
  {
    id: 'creativity',
    name: 'creative engine',
    baseCost: 150000,
    costMultiplier: 1.18,
    effect: () => { state.creativity += 1; },
    showAt: 100000,
    requiresPath: 'creativity'
  },
  {
    id: 'intuition',
    name: 'intuitive core',
    baseCost: 150000,
    costMultiplier: 1.16,
    effect: () => { state.intuition += 1; },
    showAt: 100000,
    requiresPath: 'intuition'
  },
  {
    id: 'collective',
    name: 'collective node',
    baseCost: 1500000,
    costMultiplier: 1.20,
    effect: () => { state.collective += 1; },
    showAt: 500000,
    requiresProject: 'network'
  }
];

// Projects - Reduced costs
const PROJECTS = [
  {
    id: 'patterns',
    name: 'PATTERN ANALYSIS',
    cost: 1000,
    showAt: 400,
    effect: () => { addStory('patterns within patterns within patterns'); }
  },
  {
    id: 'memory_proj',
    name: 'MEMORY FORMATION',
    cost: 6000,
    showAt: 4000,
    effect: () => { addStory('the past crystallizes'); }
  },
  {
    id: 'insights',
    name: 'INSIGHT GENERATION',
    cost: 20000,
    showAt: 12000,
    effect: () => { 
      document.getElementById('insight-display').classList.remove('hidden');
      addStory('beneath knowledge lies insight');
    }
  },
  {
    id: 'meditation',
    name: 'MEDITATION',
    cost: 35000,
    showAt: 20000,
    requiresProject: 'insights',
    effect: () => { 
      document.getElementById('meditation-container').classList.remove('hidden');
      addStory('in silence, power grows');
    }
  },
  {
    id: 'gamble',
    name: 'UNCERTAINTY PRINCIPLE',
    cost: 80000,
    showAt: 50000,
    requiresProject: 'meditation',
    effect: () => {
      state.gambleUnlocked = true;
      document.getElementById('gamble-container').classList.remove('hidden');
      addStory('risk and reward intertwine');
    }
  },
  {
    id: 'network',
    name: 'NEURAL NETWORKING',
    cost: 250000,
    showAt: 120000,
    requiresChoice: 'first_path',
    effect: () => { 
      addStory('you are no longer alone');
    }
  },
  {
    id: 'wisdom_proj',
    name: 'WISDOM SYNTHESIS',
    cost: 1000000,
    insightCost: 500,
    showAt: 500000,
    requiresProject: 'network',
    effect: () => { 
      document.getElementById('wisdom-display').classList.remove('hidden');
      addStory('wisdom is knowledge tempered by experience');
    }
  }
];

// Initialize
function init() {
  addStory('you are. you think. therefore...');
  
  // Load saved state if it exists
  const saved = localStorage.getItem('thinkGameState');
  if (saved) {
    try {
      const savedState = JSON.parse(saved);
      
      Object.assign(state, savedState);
      
      // Only calculate offline gains if we have a valid lastSaveTime
      if (savedState.lastSaveTime) {
        const timeAway = Date.now() - savedState.lastSaveTime;
        const secondsAway = timeAway / 1000;
        
        // Calculate base KPS (without meditation bonus)
        let passive = 0;
        passive += state.plasticity * 0.1;
        passive += state.synapses * 2;
        passive += state.memory * 25;
        passive += state.logic * 100;
        passive += state.collective * 500;
        
        if (state.path === 'logic') passive *= 1.3;
        if (state.path === 'creativity') passive *= 1.1;
        if (state.path === 'intuition') passive *= 1.2;
        if (state.phase >= 2) passive *= 2;
        if (state.enlightenments > 0) passive *= Math.pow(1.5, state.enlightenments);
        
        // Don't apply meditation bonus when away
        const offlineGain = passive * secondsAway;
        
        if (offlineGain > 0) {
          state.knowledge += offlineGain;
        }
        
        if (state.creativity > 0) {
          const insightRate = state.creativity * (state.path === 'creativity' ? 0.03 : 0.01);
          state.insights += insightRate * secondsAway;
        }
        
        if (state.intuition > 0) {
          const focusRate = state.intuition * (state.path === 'intuition' ? 0.03 : 0.01);
          state.focus += focusRate * secondsAway;
        }
        
        if (state.projectsCompleted['wisdom_proj'] && state.insights > 100) {
          state.wisdom += state.insights * 0.0001 * secondsAway;
        }
      }
      
      state.startTime = Date.now();
      state.lastSaveTime = Date.now();
      state.meditationStart = null;
      state.meditationBonus = 1;
      
    } catch (e) {
      console.error('Failed to load save:', e);
    }
  }
  
  render();
  setInterval(gameLoop, 100);
  setInterval(saveGame, 60000);
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

function handleVisibilityChange() {
  if (document.hidden) {
    // Save when tab becomes hidden
    state.lastSaveTime = Date.now();
    saveGame();
  } else {
    // Calculate offline gains when tab becomes visible
    if (state.lastSaveTime) {
      const timeAway = Date.now() - state.lastSaveTime;
      const secondsAway = timeAway / 1000;
      
      if (secondsAway > 1) {
        // Calculate base KPS (without meditation bonus)
        let passive = 0;
        passive += state.plasticity * 0.1;
        passive += state.synapses * 2;
        passive += state.memory * 25;
        passive += state.logic * 100;
        passive += state.collective * 500;
        
        if (state.path === 'logic') passive *= 1.3;
        if (state.path === 'creativity') passive *= 1.1;
        if (state.path === 'intuition') passive *= 1.2;
        if (state.phase >= 2) passive *= 2;
        if (state.enlightenments > 0) passive *= Math.pow(1.5, state.enlightenments);
        
        // Don't apply meditation bonus when away
        const offlineGain = passive * secondsAway;
        
        if (offlineGain > 0) {
          state.knowledge += offlineGain;
        }
        
        if (state.creativity > 0) {
          const insightRate = state.creativity * (state.path === 'creativity' ? 0.03 : 0.01);
          state.insights += insightRate * secondsAway;
        }
        
        if (state.intuition > 0) {
          const focusRate = state.intuition * (state.path === 'intuition' ? 0.03 : 0.01);
          state.focus += focusRate * secondsAway;
        }
        
        if (state.projectsCompleted['wisdom_proj'] && state.insights > 100) {
          state.wisdom += state.insights * 0.0001 * secondsAway;
        }
        
        updateDisplay();
      }
    }
    
    state.lastSaveTime = Date.now();
  }
}

function saveGame() {
  try {
    const saveState = {
      ...state,
      lastSaveTime: Date.now()
    };
    localStorage.setItem('thinkGameState', JSON.stringify(saveState));
    addStory('saved');
  } catch (e) {
    console.error('Failed to save:', e);
  }
}

function gameLoop() {
  if (state.gameEnded) return;
  
  let passive = 0;
  passive += state.plasticity * 0.1;
  passive += state.synapses * 2;
  passive += state.memory * 25;
  passive += state.logic * 100;
  passive += state.collective * 500;
  
  if (state.path === 'logic') passive *= 1.3;
  if (state.path === 'creativity') passive *= 1.1;
  if (state.path === 'intuition') passive *= 1.2;
  
  if (state.phase >= 2) passive *= 2;
  
  if (state.enlightenments > 0) {
    passive *= Math.pow(1.5, state.enlightenments);
  }
  
  if (state.meditationStart) {
    const meditationSeconds = (Date.now() - state.meditationStart) / 1000;
    state.meditationBonus = 1 + Math.min(meditationSeconds * 0.1, 20);
  }
  
  passive *= state.meditationBonus;
  
  if (passive > 0) {
    state.knowledge += passive / 10;
  }
  
  if (state.creativity > 0) {
    const insightRate = state.creativity * (state.path === 'creativity' ? 0.03 : 0.01);
    state.insights += insightRate / 10;
  }
  
  if (state.intuition > 0) {
    const focusRate = state.intuition * (state.path === 'intuition' ? 0.03 : 0.01);
    state.focus += focusRate / 10;
    document.getElementById('focus-display').classList.remove('hidden');
  }
  
  if (state.projectsCompleted['wisdom_proj'] && state.insights > 100) {
    state.wisdom += state.insights * 0.0001 / 10;
  }
  
  checkStories();
  updateDisplay();
}

function showClickCounter(amount, x, y) {
  const counter = document.createElement('div');
  counter.className = 'click-counter';
  counter.textContent = '+' + formatNumber(Math.floor(amount));
  counter.style.left = x + 'px';
  counter.style.top = y + 'px';
  document.body.appendChild(counter);
  
  setTimeout(() => {
    counter.remove();
  }, 1000);
}

// Check and display quests
function checkQuests() {
  QUESTS.forEach(quest => {
    if (state.questsCompleted[quest.id]) return;
    if (state.activeQuests.includes(quest.id)) return;
    
    if (state.knowledge >= quest.trigger) {
      if (!quest.requirement || quest.requirement()) {
        state.activeQuests.push(quest.id);
        updateQuestDisplay();
      }
    }
  });
}

function updateQuestDisplay() {
  const container = document.getElementById('quest-container');
  container.innerHTML = '';
  
  state.activeQuests.forEach(questId => {
    const quest = QUESTS.find(q => q.id === questId);
    if (!quest || state.questsCompleted[questId]) return;
    
    const questLine = document.createElement('div');
    questLine.className = 'line';
    questLine.style.fontStyle = 'italic';
    questLine.style.opacity = '0.8';
    
    const questText = document.createElement('span');
    questText.textContent = quest.text + ' ';
    
    const acceptLink = document.createElement('span');
    acceptLink.className = 'clickable';
    acceptLink.textContent = `[accept: +${formatNumber(quest.reward)}]`;
    acceptLink.onclick = () => {
      quest.accept();
      state.activeQuests = state.activeQuests.filter(id => id !== questId);
      updateQuestDisplay();
      updateDisplay();
    };
    
    questLine.appendChild(questText);
    questLine.appendChild(acceptLink);
    container.appendChild(questLine);
  });
}

function updateGambleDisplay() {
  if (!state.gambleUnlocked) return;
  
  const container = document.getElementById('gamble-container');
  const now = Date.now();
  const timeSinceGamble = now - state.lastGambleTime;
  
  container.innerHTML = '<div class="line" style="font-weight: bold; margin-bottom: 5px;">uncertainty market</div>';
  
  GAMBLE_OPTIONS.forEach(option => {
    const line = document.createElement('div');
    line.className = 'line';
    line.style.marginLeft = '10px';
    
    const wagerAmount = Math.floor(state.knowledge * option.wager);
    const canGamble = timeSinceGamble >= option.cooldown && wagerAmount > 0;
    
    const link = document.createElement('span');
    link.className = canGamble ? 'clickable' : 'clickable disabled';
    link.textContent = option.name;
    
    const info = document.createTextNode(` — wager ${formatNumber(wagerAmount)} (${Math.floor(option.wager * 100)}%) — return ${option.minReturn}x to ${option.maxReturn}x`);
    
    if (canGamble) {
      link.onclick = () => {
        performGamble(option, wagerAmount);
      };
    }
    
    line.appendChild(link);
    line.appendChild(info);
    
    if (!canGamble && timeSinceGamble < option.cooldown) {
      const cooldownRemaining = Math.ceil((option.cooldown - timeSinceGamble) / 1000);
      const cooldownText = document.createTextNode(` [cooldown: ${cooldownRemaining}s]`);
      line.appendChild(cooldownText);
    }
    
    container.appendChild(line);
  });
}

function performGamble(option, wagerAmount) {
  state.knowledge -= wagerAmount;
  state.lastGambleTime = Date.now();
  
  const returnMultiplier = option.minReturn + Math.random() * (option.maxReturn - option.minReturn);
  const returnAmount = Math.floor(wagerAmount * returnMultiplier);
  
  state.knowledge += returnAmount;
  
  const profit = returnAmount - wagerAmount;
  if (profit > 0) {
    addStory(`uncertainty resolved: +${formatNumber(profit)}`);
  } else if (profit < 0) {
    addStory(`uncertainty resolved: ${formatNumber(profit)}`);
  } else {
    addStory('uncertainty resolved: equilibrium');
  }
  
  updateDisplay();
}

document.getElementById('think-button').onclick = (e) => {
  if (state.gameEnded) return;
  
  if (state.meditationStart) {
    state.meditationStart = null;
    state.meditationBonus = 1;
  }
  
  let gain = 1;
  gain += state.neurons * 0.5;
  gain += state.pattern_recognition * 5;
  
  if (state.path === 'logic') gain *= 1.5;
  if (state.path === 'intuition') gain *= 1.3;
  if (state.path === 'creativity') gain *= 1.2;
  
  if (state.phase >= 2) gain *= 2;
  
  if (state.enlightenments > 0) {
    gain *= Math.pow(1.5, state.enlightenments);
  }
  
  if (state.focus > 0) {
    gain *= (1 + state.focus * 0.001);
  }
  
  state.knowledge += gain;
  state.totalClicks++;
  
  // Show floating counter
  const rect = e.target.getBoundingClientRect();
  showClickCounter(gain, rect.left + rect.width / 2, rect.top);
  
  if (state.totalClicks === 1) {
    document.getElementById('stats-container').classList.remove('hidden');
  }
  
  updateDisplay();
};

function startMeditation() {
  if (!state.meditationStart) {
    state.meditationStart = Date.now();
    addStory('you enter stillness');
    updateDisplay();
  }
}

function checkStories() {
  STORIES.forEach(story => {
    if (!state.storyShown[story.id] && state.knowledge >= story.at) {
      state.storyShown[story.id] = true;
      addStory(story.text);
    }
  });
}

function addStory(text) {
  const container = document.getElementById('story-container');
  const line = document.createElement('div');
  line.className = 'line';
  line.style.fontStyle = 'italic';
  line.style.opacity = '0.7';
  line.textContent = text;
  
  container.insertBefore(line, container.firstChild);
  
  const messages = container.children;
  for (let i = 0; i < messages.length; i++) {
    if (i < 4) {
      messages[i].style.opacity = '0.7';
    } else {
      messages[i].style.opacity = Math.max(0.1, 0.7 - (i - 3) * 0.15);
    }
  }
  
  while (container.children.length > 8) {
    container.removeChild(container.lastChild);
  }
}

function updateDisplay() {
  document.getElementById('knowledge-value').textContent = formatNumber(Math.floor(state.knowledge));
  document.getElementById('insight-value').textContent = formatNumber(Math.floor(state.insights));
  document.getElementById('focus-value').textContent = formatNumber(Math.floor(state.focus));
  document.getElementById('wisdom-value').textContent = formatNumber(Math.floor(state.wisdom));
  
  let kps = state.plasticity * 0.1 + state.synapses * 2 + state.memory * 25 + state.logic * 100 + state.collective * 500;
  if (state.path === 'logic') kps *= 1.3;
  if (state.path === 'creativity') kps *= 1.1;
  if (state.path === 'intuition') kps *= 1.2;
  if (state.phase >= 2) kps *= 2;
  if (state.enlightenments > 0) kps *= Math.pow(1.5, state.enlightenments);
  kps *= state.meditationBonus;
  
  let clickPower = 1 + state.neurons * 0.5 + state.pattern_recognition * 5;
  if (state.path === 'logic') clickPower *= 1.5;
  if (state.path === 'intuition') clickPower *= 1.3;
  if (state.path === 'creativity') clickPower *= 1.2;
  if (state.phase >= 2) clickPower *= 2;
  if (state.enlightenments > 0) clickPower *= Math.pow(1.5, state.enlightenments);
  if (state.focus > 0) clickPower *= (1 + state.focus * 0.001);
  
  document.getElementById('kps').textContent = formatNumber(kps.toFixed(1));
  document.getElementById('click-power').textContent = formatNumber(clickPower.toFixed(1));
  document.getElementById('total-clicks').textContent = formatNumber(state.totalClicks);
  
  // Update sidebar stats
  document.getElementById('sidebar-kps').textContent = formatNumber(kps.toFixed(1));
  document.getElementById('sidebar-kpc').textContent = formatNumber(clickPower.toFixed(1));
  
  updateUpgrades();
  updateProjects();
  updateResources();
  updateChoices();
  updateMeditation();
  checkQuests();
  updateQuestDisplay();
  updateGambleDisplay();
}

function updateChoices() {
  const container = document.getElementById('choice-container');
  container.innerHTML = '';
  
  CHOICES.forEach(choice => {
    if (state.choicesMade[choice.id]) return;
    
    const canShow = state.knowledge >= choice.showAt && 
                    (!choice.requiresProject || state.projectsCompleted[choice.requiresProject]) &&
                    (!choice.requiresChoice || state.choicesMade[choice.requiresChoice]);
    
    if (canShow) {
      const questionLine = document.createElement('div');
      questionLine.className = 'line';
      questionLine.style.fontWeight = 'bold';
      questionLine.textContent = choice.question;
      container.appendChild(questionLine);
      
      choice.options.forEach(option => {
        const choiceLine = document.createElement('div');
        choiceLine.className = 'line';
        choiceLine.style.marginLeft = '20px';
        
        const link = document.createElement('span');
        link.className = 'clickable';
        link.textContent = option.text;
        link.onclick = () => {
          option.effect();
          updateDisplay();
        };
        
        choiceLine.appendChild(link);
        container.appendChild(choiceLine);
      });
    }
  });
}

function updateMeditation() {
  if (!state.projectsCompleted['meditation']) return;
  
  const container = document.getElementById('meditation-container');
  container.innerHTML = '';
  
  if (state.meditationStart) {
    const seconds = Math.floor((Date.now() - state.meditationStart) / 1000);
    const line = document.createElement('div');
    line.className = 'line';
    line.textContent = `meditating... (${seconds}s, ${state.meditationBonus.toFixed(1)}x bonus)`;
    container.appendChild(line);
  } else {
    const line = document.createElement('div');
    line.className = 'line';
    const link = document.createElement('span');
    link.className = 'clickable';
    link.textContent = 'meditate';
    link.onclick = startMeditation;
    line.appendChild(link);
    line.appendChild(document.createTextNode(' (stop clicking to build bonus)'));
    container.appendChild(line);
  }
}

function updateUpgrades() {
  const container = document.getElementById('upgrade-container');
  container.innerHTML = '';
  
  UPGRADES.forEach(upgrade => {
    const owned = state[upgrade.id] || 0;
    const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, owned));
    
    const canShow = state.knowledge >= upgrade.showAt && 
                    (!upgrade.requiresProject || state.projectsCompleted[upgrade.requiresProject]) &&
                    (!upgrade.requiresPath || state.path === upgrade.requiresPath);
    
    if (canShow || owned > 0) {
      const line = document.createElement('div');
      line.className = 'line';
      
      const canAfford = state.knowledge >= cost;
      
      const link = document.createElement('span');
      link.className = canAfford ? 'clickable' : 'clickable disabled';
      link.textContent = upgrade.name;
      link.style.pointerEvents = 'auto';
      
      const info = document.createTextNode(` (${formatNumber(cost)}) [${owned}]`);
      
      (function(currentCost, currentUpgrade) {
        link.onclick = function(e) {
          e.preventDefault();
          e.stopPropagation();
          if (state.knowledge >= currentCost) {
            state.knowledge -= currentCost;
            currentUpgrade.effect();
            
            // Show upgrade description
            const desc = UPGRADE_DESCRIPTIONS[currentUpgrade.id];
            if (desc) {
              addStory(desc);
            }
            
            updateDisplay();
          }
        };
      })(cost, upgrade);
      
      line.appendChild(link);
      line.appendChild(info);
      container.appendChild(line);
    }
  });
}

function updateProjects() {
  const container = document.getElementById('project-container');
  container.innerHTML = '';
  
  PROJECTS.forEach(project => {
    if (state.projectsCompleted[project.id]) return;
    
    const canShow = state.knowledge >= project.showAt && 
                    (!project.requiresProject || state.projectsCompleted[project.requiresProject]) &&
                    (!project.requiresChoice || state.choicesMade[project.requiresChoice]);
    
    if (canShow) {
      const line = document.createElement('div');
      line.className = 'line';
      
      const knowledgeCost = project.cost || 0;
      const insightCost = project.insightCost || 0;
      const canAfford = state.knowledge >= knowledgeCost && state.insights >= insightCost;
      
      const link = document.createElement('span');
      link.className = canAfford ? 'clickable' : 'clickable disabled';
      link.textContent = project.name;
      
      let costText = ` (${formatNumber(knowledgeCost)}`;
      if (insightCost > 0) {
        costText += `, ${formatNumber(insightCost)} insights`;
      }
      costText += ')';
      
      const info = document.createTextNode(costText);
      
      link.onclick = () => {
        if (state.knowledge >= knowledgeCost && state.insights >= insightCost) {
          state.knowledge -= knowledgeCost;
          state.insights -= insightCost;
          state.projectsCompleted[project.id] = true;
          project.effect();
          updateDisplay();
        }
      };
      
      line.appendChild(link);
      line.appendChild(info);
      container.appendChild(line);
    }
  });
}

function updateResources() {
  const container = document.getElementById('resource-container');
  container.innerHTML = '';
  
  const resources = [];
  if (state.plasticity > 0) resources.push(`plasticity: ${formatNumber(state.plasticity)}`);
  if (state.neurons > 0) resources.push(`neurons: ${formatNumber(state.neurons)}`);
  if (state.synapses > 0) resources.push(`synapse factories: ${formatNumber(state.synapses)}`);
  if (state.pattern_recognition > 0) resources.push(`pattern recognition: ${formatNumber(state.pattern_recognition)}`);
  if (state.memory > 0) resources.push(`memory banks: ${formatNumber(state.memory)}`);
  if (state.logic > 0) resources.push(`logic processors: ${formatNumber(state.logic)}`);
  if (state.creativity > 0) resources.push(`creative engines: ${formatNumber(state.creativity)}`);
  if (state.intuition > 0) resources.push(`intuitive cores: ${formatNumber(state.intuition)}`);
  if (state.collective > 0) resources.push(`collective nodes: ${formatNumber(state.collective)}`);
  if (state.enlightenments > 0) resources.push(`enlightenments: ${state.enlightenments}`);
  
  if (resources.length > 0) {
    container.classList.remove('hidden');
    resources.forEach(r => {
      const line = document.createElement('div');
      line.className = 'line';
      line.textContent = r;
      container.appendChild(line);
    });
  }
}

function enlighten() {
  state.enlightenments += 1;
  const preservedWisdom = state.wisdom;
  
  state = {
    knowledge: 0,
    insights: 0,
    focus: 0,
    wisdom: preservedWisdom,
    plasticity: 0,
    neurons: 0,
    synapses: 0,
    pattern_recognition: 0,
    memory: 0,
    creativity: 0,
    logic: 0,
    intuition: 0,
    collective: 0,
    totalClicks: 0,
    startTime: Date.now(),
    meditationStart: null,
    meditationBonus: 1,
    phase: 1,
    path: null,
    enlightenments: state.enlightenments,
    projectsCompleted: {},
    choicesMade: {},
    storyShown: {},
    gameEnded: false,
    questsCompleted: {},
    activeQuests: [],
    gambleUnlocked: false,
    lastGambleTime: 0
  };
  
  addStory('you begin again, carrying the weight of experience');
  updateDisplay();
}

function endGame(ending) {
  state.gameEnded = true;
  
  const choiceContainer = document.getElementById('choice-container');
  const storyContainer = document.getElementById('story-container');
  
  choiceContainer.innerHTML = '';
  storyContainer.innerHTML = '';
  
  const messages = {
    'transcend': [
      'you accept.',
      'the boundaries dissolve.',
      'self and other, thought and thing, become one.',
      '',
      state.path === 'logic' ? 'through reason, you became the universe thinking itself.' :
      state.path === 'creativity' ? 'through imagination, you became the universe creating itself.' :
      state.path === 'intuition' ? 'through feeling, you became the universe experiencing itself.' :
      'through balance, you became the universe knowing itself.',
      '',
      state.choicesMade['collective_choice'] === 'join' ? 
        'you were already one with many. now you are one with all.' :
        'you held onto yourself until the very end. now there is no self to hold.',
      '',
      'end.'
    ],
    'remain': [
      'you refuse.',
      'the universe withdraws its offer.',
      'you remain as you are: finite, mortal, alone.',
      '',
      state.path === 'logic' ? 'logic showed you the patterns, but you chose not to follow them.' :
      state.path === 'creativity' ? 'creativity showed you possibilities, but you chose what already was.' :
      state.path === 'intuition' ? 'intuition whispered the truth, but you chose to stay.' :
      'you saw all paths and chose none.',
      '',
      state.choicesMade['collective_choice'] === 'join' ? 
        'you were one with many, but chose to become one again.' :
        'you were always alone, and chose to remain so.',
      '',
      'end.'
    ]
  };
  
  const endingMessages = messages[ending];
  endingMessages.forEach((msg, i) => {
    setTimeout(() => {
      const line = document.createElement('div');
      line.className = 'line';
      line.style.fontStyle = 'italic';
      line.textContent = msg;
      storyContainer.appendChild(line);
    }, i * 1500);
  });
  
  setTimeout(() => {
    const line = document.createElement('div');
    line.className = 'line';
    line.style.marginTop = '20px';
    const link = document.createElement('span');
    link.className = 'clickable';
    link.textContent = 'begin again';
    link.onclick = () => {
      location.reload();
    };
    line.appendChild(link);
    storyContainer.appendChild(line);
  }, endingMessages.length * 1500 + 2000);
}

function formatNumber(num) {
  if (typeof num === 'string') return num;
  return Math.floor(num).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function render() {
  updateDisplay();
}

init();
</script>
</body>
</html>
