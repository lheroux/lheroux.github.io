<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>think</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 40px 20px;
      font-family: "Times New Roman", serif;
      background: #fff;
      color: #000;
      line-height: 1.8;
      font-size: 14px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    #game-container {
      max-width: 600px;
      margin: 0 auto;
    }
    
    .clickable {
      cursor: pointer;
      user-select: none;
      display: inline;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
      transition: opacity 0.1s;
    }
    
    .clickable:hover {
      text-decoration: underline;
    }
    
    .clickable:active {
      opacity: 0.7;
      transform: scale(0.98);
    }
    
    .line {
      margin: 3px 0;
      transition: opacity 0.2s ease;
    }
    
    .hidden {
      display: none !important;
    }
    
    .disabled {
      opacity: 0.3;
      cursor: not-allowed !important;
    }
    
    .disabled:hover {
      text-decoration: none !important;
    }
    
    .section-gap {
      margin-top: 20px;
    }
    
    .indent {
      margin-left: 20px;
    }
    
    .story-text {
      font-style: italic;
      opacity: 0.6;
    }
    
    .footer-link {
      position: fixed;
      bottom: 10px;
      font-size: 0.9em;
      text-decoration: none;
      color: #000;
      cursor: pointer;
    }
    
    #settings-link {
      left: 10px;
    }
    
    #home-link {
      right: 10px;
    }
    
    #save-indicator {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 0.8em;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .settings-content {
      background: #fff;
      padding: 30px;
      max-width: 400px;
      width: 90%;
    }
    
    .setting-item {
      margin: 15px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .click-particle {
      position: fixed;
      pointer-events: none;
      font-size: 1em;
      color: #000;
      animation: floatUp 1s ease-out forwards;
      z-index: 999;
    }
    
    @keyframes floatUp {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-40px);
      }
    }
    
    input[type="checkbox"] {
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="game-container">
    <div class="line">
      <span class="clickable" id="think-button">think</span>
      <span id="enlightenment-text"></span>
    </div>
    
    <div class="line section-gap">
      knowledge: <span id="knowledge-value">0</span>
    </div>
    
    <div class="line">
      knowledge per second: <span id="kps-value">0</span>
    </div>
    
    <div class="line">
      knowledge per click: <span id="click-power">1</span>
    </div>
    
    <div class="line hidden" id="insight-line">
      insights: <span id="insight-value">0</span>
    </div>
    
    <div class="line hidden" id="focus-line">
      focus: <span id="focus-value">0</span>
    </div>
    
    <div class="line hidden" id="wisdom-line">
      wisdom: <span id="wisdom-value">0</span>
    </div>
    
    <div id="choice-container" class="section-gap"></div>
    
    <div id="meditation-container" class="hidden section-gap"></div>
    
    <div id="project-container" class="section-gap"></div>
    
    <div id="upgrade-container" class="section-gap"></div>
    
    <div id="resource-container" class="hidden section-gap"></div>
    
    <div id="story-container" class="section-gap"></div>
  </div>
  
  <div id="settings-link" class="footer-link clickable">settings</div>
  <div id="home-link" class="footer-link clickable">home</div>
  
  <div id="save-indicator">saved</div>
  
  <div id="settings-modal" class="settings-modal">
    <div class="settings-content">
      <div class="line" style="font-weight: bold; margin-bottom: 20px;">settings</div>
      
      <div class="setting-item">
        <div>auto-save</div>
        <input type="checkbox" id="setting-autosave" checked>
      </div>
      
      <div class="setting-item">
        <div>offline progress</div>
        <input type="checkbox" id="setting-offline" checked>
      </div>
      
      <div class="setting-item">
        <div>click particles</div>
        <input type="checkbox" id="setting-particles" checked>
      </div>
      
      <div class="line" style="margin-top: 30px; text-align: center;">
        <span class="clickable" id="export-save" style="margin-right: 20px;">export</span>
        <span class="clickable" id="import-save" style="margin-right: 20px;">import</span>
        <span class="clickable" id="reset-game" style="opacity: 0.5;">reset</span>
      </div>
      
      <div class="line" style="margin-top: 20px; text-align: center;">
        <span class="clickable" id="settings-close">close</span>
      </div>
    </div>
  </div>

<script>
// DOM element cache
const elements = {};

// Game state
let state = {
  knowledge: 0,
  insights: 0,
  focus: 0,
  wisdom: 0,
  plasticity: 0,
  neurons: 0,
  synapses: 0,
  pattern_recognition: 0,
  memory: 0,
  creativity: 0,
  logic: 0,
  intuition: 0,
  collective: 0,
  totalClicks: 0,
  startTime: Date.now(),
  meditationStart: null,
  meditationBonus: 1,
  phase: 1,
  path: null,
  enlightenments: 0,
  projectsCompleted: {},
  choicesMade: {},
  storyShown: {},
  gameEnded: false,
  lastUpdate: Date.now(),
  lastSave: Date.now(),
  lastActiveTime: Date.now()
};

// Cache for display updates
let lastDisplayValues = {};
let lastUpdateTime = 0;
const DISPLAY_UPDATE_INTERVAL = 100; // Update display every 100ms instead of 50ms

// Settings
let settings = {
  autoSave: true,
  offlineProgress: true,
  particles: true
};

// Story beats
const STORIES = [
  { at: 10, id: 'awareness', text: 'awareness emerges from the void' },
  { at: 50, id: 'plasticity', text: 'your mind begins to reshape itself' },
  { at: 200, id: 'neurons', text: 'neural pathways form and strengthen' },
  { at: 1000, id: 'patterns', text: 'patterns reveal themselves in the chaos' },
  { at: 5000, id: 'memory', text: 'memory allows you to build upon the past' },
  { at: 25000, id: 'question', text: 'but what are you becoming?' },
  { at: 100000, id: 'others', text: 'you sense others like you, thinking, growing' },
  { at: 500000, id: 'collective_sense', text: 'the boundary between minds grows thin' },
  { at: 2000000, id: 'approach', text: 'something approaches. a choice must be made.' }
];

// Major choices
const CHOICES = [
  {
    id: 'first_path',
    showAt: 25000,
    question: 'how will you grow?',
    options: [
      { id: 'logic', text: 'through reason and analysis', effect: () => {
        state.path = 'logic';
        state.choicesMade['first_path'] = 'logic';
        addStory('you choose the path of logic');
      }},
      { id: 'creativity', text: 'through imagination and creation', effect: () => {
        state.path = 'creativity';
        state.choicesMade['first_path'] = 'creativity';
        addStory('you choose the path of creativity');
      }},
      { id: 'intuition', text: 'through feeling and instinct', effect: () => {
        state.path = 'intuition';
        state.choicesMade['first_path'] = 'intuition';
        addStory('you choose the path of intuition');
      }}
    ]
  },
  {
    id: 'collective_choice',
    showAt: 500000,
    requiresProject: 'network',
    question: 'others reach out. do you...',
    options: [
      { id: 'join', text: 'merge with the collective', effect: () => {
        state.choicesMade['collective_choice'] = 'join';
        state.phase = 2;
        addStory('you dissolve into the many');
      }},
      { id: 'remain', text: 'remain separate', effect: () => {
        state.choicesMade['collective_choice'] = 'remain';
        state.phase = 2;
        addStory('you hold onto yourself');
      }}
    ]
  },
  {
    id: 'final_choice',
    showAt: 5000000,
    requiresChoice: 'collective_choice',
    question: 'the universe offers transcendence. but at what cost?',
    options: [
      { id: 'transcend', text: 'accept. become everything.', effect: () => {
        endGame('transcend');
      }},
      { id: 'remain_mortal', text: 'refuse. stay as you are.', effect: () => {
        endGame('remain');
      }},
      { id: 'enlighten', text: 'start again, wiser.', effect: () => {
        enlighten();
      }}
    ]
  }
];

// Upgrades
const UPGRADES = [
  {
    id: 'plasticity',
    name: 'plasticity',
    baseCost: 15,
    costMultiplier: 1.15,
    effect: () => { state.plasticity += 1; },
    showAt: 0
  },
  {
    id: 'neurons',
    name: 'neuron',
    baseCost: 100,
    costMultiplier: 1.12,
    effect: () => { state.neurons += 1; },
    showAt: 50
  },
  {
    id: 'synapses',
    name: 'synapse factory',
    baseCost: 1200,
    costMultiplier: 1.14,
    effect: () => { state.synapses += 1; },
    showAt: 500
  },
  {
    id: 'pattern_recognition',
    name: 'pattern recognition',
    baseCost: 8500,
    costMultiplier: 1.16,
    effect: () => { state.pattern_recognition += 1; },
    showAt: 5000,
    requiresProject: 'patterns'
  },
  {
    id: 'memory',
    name: 'memory bank',
    baseCost: 45000,
    costMultiplier: 1.13,
    effect: () => { state.memory += 1; },
    showAt: 25000,
    requiresProject: 'memory_proj'
  },
  {
    id: 'logic',
    name: 'logic processor',
    baseCost: 150000,
    costMultiplier: 1.17,
    effect: () => { state.logic += 1; },
    showAt: 100000,
    requiresPath: 'logic'
  },
  {
    id: 'creativity',
    name: 'creative engine',
    baseCost: 150000,
    costMultiplier: 1.18,
    effect: () => { state.creativity += 1; },
    showAt: 100000,
    requiresPath: 'creativity'
  },
  {
    id: 'intuition',
    name: 'intuitive core',
    baseCost: 150000,
    costMultiplier: 1.16,
    effect: () => { state.intuition += 1; },
    showAt: 100000,
    requiresPath: 'intuition'
  },
  {
    id: 'collective',
    name: 'collective node',
    baseCost: 1500000,
    costMultiplier: 1.20,
    effect: () => { state.collective += 1; },
    showAt: 500000,
    requiresProject: 'network'
  }
];

// Projects
const PROJECTS = [
  {
    id: 'patterns',
    name: 'PATTERN ANALYSIS',
    cost: 2500,
    showAt: 1000,
    effect: () => { addStory('patterns within patterns within patterns'); }
  },
  {
    id: 'memory_proj',
    name: 'MEMORY FORMATION',
    cost: 15000,
    showAt: 10000,
    effect: () => { addStory('the past crystallizes'); }
  },
  {
    id: 'insights',
    name: 'INSIGHT GENERATION',
    cost: 50000,
    showAt: 30000,
    effect: () => { 
      document.getElementById('insight-line').classList.remove('hidden');
      addStory('beneath knowledge lies insight');
    }
  },
  {
    id: 'meditation',
    name: 'MEDITATION',
    cost: 75000,
    showAt: 50000,
    requiresProject: 'insights',
    effect: () => { 
      document.getElementById('meditation-container').classList.remove('hidden');
      addStory('in silence, power grows');
    }
  },
  {
    id: 'network',
    name: 'NEURAL NETWORKING',
    cost: 500000,
    showAt: 250000,
    requiresChoice: 'first_path',
    effect: () => { 
      addStory('you are no longer alone');
    }
  },
  {
    id: 'wisdom_proj',
    name: 'WISDOM SYNTHESIS',
    cost: 2000000,
    insightCost: 500,
    showAt: 1000000,
    requiresProject: 'network',
    effect: () => { 
      document.getElementById('wisdom-line').classList.remove('hidden');
      addStory('wisdom is knowledge tempered by experience');
    }
  }
];

// Particle effect
function createParticle(x, y, text) {
  if (!settings.particles) return;
  
  const particle = document.createElement('div');
  particle.className = 'click-particle';
  particle.textContent = text;
  particle.style.left = (x || 0) + 'px';
  particle.style.top = (y || 0) + 'px';
  
  document.body.appendChild(particle);
  
  setTimeout(() => {
    if (particle.parentNode) particle.remove();
  }, 1000);
}

// Save/Load
function saveGame() {
  try {
    state.lastSave = Date.now();
    localStorage.setItem('thinkGameState', JSON.stringify(state));
  } catch (e) {
    console.error('Failed to save:', e);
  }
}

function loadGame() {
  // Check if this is a reset (URL param)
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('_reset')) {
    // Clean URL
    window.history.replaceState({}, '', window.location.pathname);
    // Explicitly reset state to initial values
    state = {
      knowledge: 0,
      insights: 0,
      focus: 0,
      wisdom: 0,
      plasticity: 0,
      neurons: 0,
      synapses: 0,
      pattern_recognition: 0,
      memory: 0,
      creativity: 0,
      logic: 0,
      intuition: 0,
      collective: 0,
      totalClicks: 0,
      startTime: Date.now(),
      meditationStart: null,
      meditationBonus: 1,
      phase: 1,
      path: null,
      enlightenments: 0,
      projectsCompleted: {},
      choicesMade: {},
      storyShown: {},
      gameEnded: false,
      lastUpdate: Date.now(),
      lastSave: Date.now(),
      lastActiveTime: Date.now()
    };
    // Clear all display caches
    lastDisplayValues = {};
    lastChoicesHash = '';
    lastProjectsHash = '';
    lastUpgradesHash = '';
    lastResourcesHash = '';
    lastMeditationState = null;
    return; // Don't load saved game
  }
  
  const saved = localStorage.getItem('thinkGameState');
  if (saved) {
    try {
      const savedState = JSON.parse(saved);
      
      const timeAway = Date.now() - savedState.lastSave;
      if (settings.offlineProgress && timeAway > 1000) {
        calculateOfflineProgress(savedState, timeAway);
      }
      
      Object.assign(state, savedState);
      state.lastUpdate = Date.now();
      state.meditationStart = null;
      state.meditationBonus = 1;
      
      const minutes = Math.floor(timeAway / 60000);
      if (minutes > 0) {
        addStory(`welcome back. ${minutes} minute${minutes !== 1 ? 's' : ''} passed`);
      }
    } catch (e) {
      console.error('Failed to load save:', e);
    }
  }
}

function loadSettings() {
  const saved = localStorage.getItem('thinkSettings');
  if (saved) {
    try {
      settings = JSON.parse(saved);
    } catch (e) {}
  }
  
  document.getElementById('setting-autosave').checked = settings.autoSave;
  document.getElementById('setting-offline').checked = settings.offlineProgress;
  document.getElementById('setting-particles').checked = settings.particles;
}

function saveSettings() {
  settings.autoSave = document.getElementById('setting-autosave').checked;
  settings.offlineProgress = document.getElementById('setting-offline').checked;
  settings.particles = document.getElementById('setting-particles').checked;
  
  localStorage.setItem('thinkSettings', JSON.stringify(settings));
}

// Offline progress
function calculateOfflineProgress(savedState, timeAway) {
  const secondsAway = Math.min(timeAway / 1000, 86400);
  
  let kps = calculateKPS(savedState);
  state.knowledge += kps * secondsAway;
  
  if (savedState.creativity > 0) {
    const insightRate = savedState.creativity * (savedState.path === 'creativity' ? 0.03 : 0.01);
    state.insights += insightRate * secondsAway;
  }
  
  if (savedState.intuition > 0) {
    const focusRate = savedState.intuition * (savedState.path === 'intuition' ? 0.03 : 0.01);
    state.focus += focusRate * secondsAway;
  }
  
  if (savedState.projectsCompleted['wisdom_proj'] && savedState.insights > 100) {
    state.wisdom += savedState.insights * 0.0001 * secondsAway;
  }
}

function calculateKPS(s = state) {
  let kps = 0;
  kps += s.plasticity * 0.1;
  kps += s.synapses * 2;
  kps += s.memory * 25;
  kps += s.logic * 100;
  kps += s.creativity * 100;
  kps += s.intuition * 100;
  kps += s.collective * 500;
  
  if (s.path === 'logic') kps *= 1.3;
  else if (s.path === 'creativity') kps *= 1.1;
  else if (s.path === 'intuition') kps *= 1.2;
  
  if (s.phase >= 2) kps *= 2;
  if (s.enlightenments > 0) kps *= Math.pow(1.5, s.enlightenments);
  if (s.meditationBonus) kps *= s.meditationBonus;
  
  return kps;
}

function calculateClickPower() {
  let power = 1;
  power += state.neurons * 0.5;
  power += state.pattern_recognition * 5;
  
  if (state.path === 'logic') power *= 1.5;
  else if (state.path === 'intuition') power *= 1.3;
  else if (state.path === 'creativity') power *= 1.2;
  
  if (state.phase >= 2) power *= 2;
  if (state.enlightenments > 0) power *= Math.pow(1.5, state.enlightenments);
  if (state.focus > 0) power *= (1 + state.focus * 0.001);
  
  // Early game boost for better playability
  if (state.knowledge < 100) {
    power *= 1.5;
  } else if (state.knowledge < 500) {
    power *= 1.2;
  }
  
  return power;
}

function handleVisibilityChange() {
  if (document.hidden) {
    state.lastActiveTime = Date.now();
    saveGame();
  } else {
    const timeAway = Date.now() - state.lastActiveTime;
    if (settings.offlineProgress && timeAway > 1000) {
      calculateOfflineProgress(state, timeAway);
      updateDisplay();
    }
  }
}

// Game loop
let lastFrameTime = 0;

function gameLoop(currentTime) {
  if (state.gameEnded) return;
  
  // Handle first frame and large time gaps
  if (lastFrameTime === 0) {
    lastFrameTime = currentTime || Date.now();
    requestAnimationFrame(gameLoop);
    return;
  }
  
  let deltaTime = ((currentTime || Date.now()) - lastFrameTime) / 1000;
  if (deltaTime > 1) deltaTime = 1; // Cap deltaTime to prevent huge jumps
  if (deltaTime < 0) deltaTime = 0; // Prevent negative time
  lastFrameTime = currentTime || Date.now();
  
  // Update game state every frame for smoothness
  if (state.meditationStart) {
    const meditationSeconds = (Date.now() - state.meditationStart) / 1000;
    state.meditationBonus = 1 + Math.min(meditationSeconds * 0.1, 20);
  }
  
  const kps = calculateKPS();
  if (kps > 0) {
    state.knowledge += kps * deltaTime;
  }
  
  if (state.creativity > 0) {
    const insightRate = state.creativity * (state.path === 'creativity' ? 0.03 : 0.01);
    state.insights += insightRate * deltaTime;
  }
  
  if (state.intuition > 0) {
    const focusRate = state.intuition * (state.path === 'intuition' ? 0.03 : 0.01);
    state.focus += focusRate * deltaTime;
  }
  
  if (state.projectsCompleted['wisdom_proj'] && state.insights > 100) {
    state.wisdom += state.insights * 0.0001 * deltaTime;
  }
  
  checkStories();
  
  // Throttle display updates
  const now = currentTime || Date.now();
  if (now - lastUpdateTime >= DISPLAY_UPDATE_INTERVAL) {
    updateDisplay();
    lastUpdateTime = now;
  } else {
    // Still update critical numbers every frame for smoothness
    updateCriticalNumbers();
  }
  
  requestAnimationFrame(gameLoop);
}

// Stories
function checkStories() {
  STORIES.forEach(story => {
    if (!state.storyShown[story.id] && state.knowledge >= story.at) {
      state.storyShown[story.id] = true;
      addStory(story.text);
    }
  });
}

function addStory(text) {
  const container = document.getElementById('story-container');
  const line = document.createElement('div');
  line.className = 'line story-text';
  line.textContent = text;
  
  container.insertBefore(line, container.firstChild);
  
  const messages = container.children;
  for (let i = 0; i < messages.length; i++) {
    if (i < 5) {
      messages[i].style.opacity = '0.6';
    } else {
      messages[i].style.opacity = Math.max(0.1, 0.6 - (i - 4) * 0.1);
    }
  }
  
  while (container.children.length > 10) {
    container.removeChild(container.lastChild);
  }
}

// Update only critical numbers (called every frame)
function updateCriticalNumbers() {
  if (!elements['knowledge-value']) {
    elements['knowledge-value'] = document.getElementById('knowledge-value');
    elements['kps-value'] = document.getElementById('kps-value');
    if (!elements['knowledge-value']) return;
  }
  
  const knowledgeText = formatNumber(state.knowledge);
  if (lastDisplayValues.knowledge !== knowledgeText) {
    elements['knowledge-value'].textContent = knowledgeText;
    lastDisplayValues.knowledge = knowledgeText;
  }
  
  const kps = calculateKPS();
  const kpsText = kps < 1000 ? kps.toFixed(1) : formatNumber(kps);
  if (lastDisplayValues.kps !== kpsText) {
    elements['kps-value'].textContent = kpsText;
    lastDisplayValues.kps = kpsText;
  }
}

// Update display (throttled)
function updateDisplay() {
  // Cache elements on first call
  if (!elements['knowledge-value']) {
    elements['knowledge-value'] = document.getElementById('knowledge-value');
    elements['insight-value'] = document.getElementById('insight-value');
    elements['focus-value'] = document.getElementById('focus-value');
    elements['wisdom-value'] = document.getElementById('wisdom-value');
    elements['kps-value'] = document.getElementById('kps-value');
    elements['click-power'] = document.getElementById('click-power');
    elements['enlightenment-text'] = document.getElementById('enlightenment-text');
  }
  
  // Update numbers only if changed
  const knowledgeText = formatNumber(state.knowledge);
  if (lastDisplayValues.knowledge !== knowledgeText) {
    elements['knowledge-value'].textContent = knowledgeText;
    lastDisplayValues.knowledge = knowledgeText;
  }
  
  const insightLine = elements['insight-line'] || document.getElementById('insight-line');
  if (insightLine && !insightLine.classList.contains('hidden')) {
    const insightText = formatNumber(state.insights);
    if (lastDisplayValues.insights !== insightText) {
      elements['insight-value'].textContent = insightText;
      lastDisplayValues.insights = insightText;
    }
  }
  
  const focusLine = elements['focus-line'] || document.getElementById('focus-line');
  if (focusLine && !focusLine.classList.contains('hidden')) {
    const focusText = formatNumber(state.focus);
    if (lastDisplayValues.focus !== focusText) {
      elements['focus-value'].textContent = focusText;
      lastDisplayValues.focus = focusText;
    }
  }
  
  const wisdomLine = elements['wisdom-line'] || document.getElementById('wisdom-line');
  if (wisdomLine && !wisdomLine.classList.contains('hidden')) {
    const wisdomText = formatNumber(state.wisdom);
    if (lastDisplayValues.wisdom !== wisdomText) {
      elements['wisdom-value'].textContent = wisdomText;
      lastDisplayValues.wisdom = wisdomText;
    }
  }
  
  const kps = calculateKPS();
  const clickPower = calculateClickPower();
  
  const kpsText = kps < 1000 ? kps.toFixed(1) : formatNumber(kps);
  if (lastDisplayValues.kps !== kpsText) {
    elements['kps-value'].textContent = kpsText;
    lastDisplayValues.kps = kpsText;
  }
  
  const clickPowerText = clickPower < 1000 ? clickPower.toFixed(1) : formatNumber(clickPower);
  if (lastDisplayValues.clickPower !== clickPowerText) {
    elements['click-power'].textContent = clickPowerText;
    lastDisplayValues.clickPower = clickPowerText;
  }
  
  if (state.enlightenments > 0) {
    const enlightenmentText = ` (enlightenments: ${state.enlightenments})`;
    if (lastDisplayValues.enlightenment !== enlightenmentText) {
      elements['enlightenment-text'].textContent = enlightenmentText;
      lastDisplayValues.enlightenment = enlightenmentText;
    }
  } else if (lastDisplayValues.enlightenment !== '') {
    elements['enlightenment-text'].textContent = '';
    lastDisplayValues.enlightenment = '';
  }
  
  // Only update containers if they might have changed
  updateChoices();
  updateMeditation();
  updateProjects();
  updateUpgrades();
  updateResources();
}

// Update choices
let lastChoicesHash = '';
function updateChoices() {
  const container = elements['choice-container'] || (elements['choice-container'] = document.getElementById('choice-container'));
  
  // Build hash of visible choices to avoid unnecessary rebuilds
  const visibleChoices = CHOICES.filter(choice => 
    !state.choicesMade[choice.id] &&
    state.knowledge >= choice.showAt && 
    (!choice.requiresProject || state.projectsCompleted[choice.requiresProject]) &&
    (!choice.requiresChoice || state.choicesMade[choice.requiresChoice])
  );
  
  const choicesHash = visibleChoices.map(c => c.id).join(',');
  if (choicesHash === lastChoicesHash && container.children.length > 0) return;
  lastChoicesHash = choicesHash;
  
  container.innerHTML = '';
  
  visibleChoices.forEach(choice => {
    const questionLine = document.createElement('div');
    questionLine.className = 'line';
    questionLine.textContent = choice.question;
    container.appendChild(questionLine);
    
    choice.options.forEach(option => {
      const optionLine = document.createElement('div');
      optionLine.className = 'line indent';
      
      const link = document.createElement('span');
      link.className = 'clickable';
      link.textContent = option.text;
      link.addEventListener('click', () => {
        option.effect();
        updateDisplay();
      });
      
      optionLine.appendChild(link);
      container.appendChild(optionLine);
    });
  });
}

// Update meditation
let lastMeditationState = null;
function updateMeditation() {
  if (!state.projectsCompleted['meditation']) return;
  
  const container = elements['meditation-container'] || (elements['meditation-container'] = document.getElementById('meditation-container'));
  
  const isMeditating = !!state.meditationStart;
  const seconds = isMeditating ? Math.floor((Date.now() - state.meditationStart) / 1000) : 0;
  const currentState = `${isMeditating}-${seconds}-${state.meditationBonus.toFixed(1)}`;
  
  if (currentState === lastMeditationState) return;
  lastMeditationState = currentState;
  
  container.innerHTML = '';
  
  if (isMeditating) {
    const line = document.createElement('div');
    line.className = 'line';
    line.textContent = `meditating... ${seconds}s (${state.meditationBonus.toFixed(1)}x bonus)`;
    container.appendChild(line);
  } else {
    const line = document.createElement('div');
    line.className = 'line';
    
    const btn = document.createElement('span');
    btn.className = 'clickable';
    btn.textContent = 'meditate';
    btn.addEventListener('click', startMeditation);
    
    line.appendChild(btn);
    container.appendChild(line);
  }
}

function startMeditation() {
  if (!state.meditationStart) {
    state.meditationStart = Date.now();
    addStory('you enter stillness...');
    updateDisplay();
  }
}

// Update projects
let lastProjectsHash = '';
function updateProjects() {
  const container = elements['project-container'] || (elements['project-container'] = document.getElementById('project-container'));
  
  const visibleProjects = PROJECTS.filter(p => !state.projectsCompleted[p.id] && 
    state.knowledge >= p.showAt && 
    (!p.requiresProject || state.projectsCompleted[p.requiresProject]) &&
    (!p.requiresChoice || state.choicesMade[p.requiresChoice]));
  
  // Build hash to detect changes
  const projectsHash = visibleProjects.map(p => {
    const knowledgeCost = p.cost || 0;
    const insightCost = p.insightCost || 0;
    const canAfford = state.knowledge >= knowledgeCost && state.insights >= insightCost;
    return `${p.id}-${canAfford}`;
  }).join(',');
  
  if (projectsHash === lastProjectsHash && container.children.length > 0) return;
  lastProjectsHash = projectsHash;
  
  if (visibleProjects.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = '<div class="line" style="font-weight: bold;">projects</div>';
  
  visibleProjects.forEach(project => {
    const line = document.createElement('div');
    line.className = 'line indent';
    
    const knowledgeCost = project.cost || 0;
    const insightCost = project.insightCost || 0;
    const canAfford = state.knowledge >= knowledgeCost && state.insights >= insightCost;
    
    const link = document.createElement('span');
    link.className = canAfford ? 'clickable' : 'clickable disabled';
    link.textContent = project.name;
    
    let costText = ` (${formatNumber(knowledgeCost)}`;
    if (insightCost > 0) {
      costText += `, ${formatNumber(insightCost)} insights`;
    }
    costText += ')';
    
    link.addEventListener('click', () => {
      if (state.knowledge >= knowledgeCost && state.insights >= insightCost) {
        state.knowledge -= knowledgeCost;
        state.insights -= insightCost;
        state.projectsCompleted[project.id] = true;
        project.effect();
        lastProjectsHash = ''; // Force update
        updateDisplay();
      }
    });
    
    line.appendChild(link);
    line.appendChild(document.createTextNode(costText));
    container.appendChild(line);
  });
}

// Update upgrades
let lastUpgradesHash = '';
function updateUpgrades() {
  const container = elements['upgrade-container'] || (elements['upgrade-container'] = document.getElementById('upgrade-container'));
  
  const visibleUpgrades = UPGRADES.filter(u => {
    const owned = state[u.id] || 0;
    return (state.knowledge >= u.showAt && 
           (!u.requiresProject || state.projectsCompleted[u.requiresProject]) &&
           (!u.requiresPath || state.path === u.requiresPath)) || owned > 0;
  });
  
  // Build hash to detect changes
  const upgradesHash = visibleUpgrades.map(u => {
    const owned = state[u.id] || 0;
    const cost = Math.floor(u.baseCost * Math.pow(u.costMultiplier, owned));
    const canAfford = state.knowledge >= cost;
    return `${u.id}-${owned}-${canAfford}`;
  }).join(',');
  
  if (upgradesHash === lastUpgradesHash && container.children.length > 0) return;
  lastUpgradesHash = upgradesHash;
  
  if (visibleUpgrades.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = '<div class="line" style="font-weight: bold;">upgrades</div>';
  
  visibleUpgrades.forEach(upgrade => {
    const owned = state[upgrade.id] || 0;
    const cost = Math.floor(upgrade.baseCost * Math.pow(upgrade.costMultiplier, owned));
    
    const line = document.createElement('div');
    line.className = 'line indent';
    
    const canAfford = state.knowledge >= cost;
    
    const link = document.createElement('span');
    link.className = canAfford ? 'clickable' : 'clickable disabled';
    link.textContent = upgrade.name;
    
    link.addEventListener('click', () => {
      if (state.knowledge >= cost) {
        state.knowledge -= cost;
        upgrade.effect();
        lastUpgradesHash = ''; // Force update
        updateDisplay();
      }
    });
    
    const info = document.createTextNode(` (${formatNumber(cost)}) [${owned}]`);
    
    line.appendChild(link);
    line.appendChild(info);
    container.appendChild(line);
  });
}

// Update resources
let lastResourcesHash = '';
function updateResources() {
  const container = elements['resource-container'] || (elements['resource-container'] = document.getElementById('resource-container'));
  
  const resources = [];
  if (state.plasticity > 0) resources.push(`plasticity: ${formatNumber(state.plasticity)}`);
  if (state.neurons > 0) resources.push(`neurons: ${formatNumber(state.neurons)}`);
  if (state.synapses > 0) resources.push(`synapse factories: ${formatNumber(state.synapses)}`);
  if (state.pattern_recognition > 0) resources.push(`pattern recognition: ${formatNumber(state.pattern_recognition)}`);
  if (state.memory > 0) resources.push(`memory banks: ${formatNumber(state.memory)}`);
  if (state.logic > 0) resources.push(`logic processors: ${formatNumber(state.logic)}`);
  if (state.creativity > 0) resources.push(`creative engines: ${formatNumber(state.creativity)}`);
  if (state.intuition > 0) resources.push(`intuitive cores: ${formatNumber(state.intuition)}`);
  if (state.collective > 0) resources.push(`collective nodes: ${formatNumber(state.collective)}`);
  
  const resourcesHash = resources.join('|');
  if (resourcesHash === lastResourcesHash) return;
  lastResourcesHash = resourcesHash;
  
  if (resources.length > 0) {
    container.classList.remove('hidden');
    container.innerHTML = '<div class="line" style="font-weight: bold;">resources</div>';
    resources.forEach(r => {
      const line = document.createElement('div');
      line.className = 'line indent';
      line.textContent = r;
      container.appendChild(line);
    });
  } else {
    container.classList.add('hidden');
  }
}

// Enlightenment
function enlighten() {
  state.enlightenments += 1;
  const preservedWisdom = state.wisdom;
  
  state = {
    knowledge: 0,
    insights: 0,
    focus: 0,
    wisdom: preservedWisdom,
    plasticity: 0,
    neurons: 0,
    synapses: 0,
    pattern_recognition: 0,
    memory: 0,
    creativity: 0,
    logic: 0,
    intuition: 0,
    collective: 0,
    totalClicks: 0,
    startTime: Date.now(),
    meditationStart: null,
    meditationBonus: 1,
    phase: 1,
    path: null,
    enlightenments: state.enlightenments,
    projectsCompleted: {},
    choicesMade: {},
    storyShown: {},
    gameEnded: false,
    lastUpdate: Date.now(),
    lastSave: Date.now(),
    lastActiveTime: Date.now()
  };
  
  addStory(`you begin again, carrying wisdom (+${(Math.pow(1.5, state.enlightenments) * 100 - 100).toFixed(0)}% production)`);
  updateDisplay();
}

// End game
function endGame(ending) {
  state.gameEnded = true;
  
  const container = document.getElementById('choice-container');
  const storyContainer = document.getElementById('story-container');
  
  container.innerHTML = '';
  storyContainer.innerHTML = '';
  
  const messages = {
    'transcend': [
      'you accept.',
      'the boundaries dissolve.',
      'self and other, thought and thing, become one.',
      '',
      state.path === 'logic' ? 'through reason, you became the universe thinking itself.' :
      state.path === 'creativity' ? 'through imagination, you became the universe creating itself.' :
      state.path === 'intuition' ? 'through feeling, you became the universe experiencing itself.' :
      'through balance, you became the universe knowing itself.',
      '',
      'end.'
    ],
    'remain': [
      'you refuse.',
      'the universe withdraws its offer.',
      'you remain as you are: finite, mortal, separate.',
      '',
      'but perhaps that is enough.',
      '',
      'end.'
    ]
  };
  
  const endingMessages = messages[ending];
  endingMessages.forEach((msg, i) => {
    setTimeout(() => {
      const line = document.createElement('div');
      line.className = 'line story-text';
      line.textContent = msg;
      storyContainer.appendChild(line);
    }, i * 1500);
  });
  
  setTimeout(() => {
    const line = document.createElement('div');
    line.className = 'line';
    line.style.marginTop = '20px';
    const link = document.createElement('span');
    link.className = 'clickable';
    link.textContent = 'begin again';
    link.onclick = () => location.reload();
    line.appendChild(link);
    storyContainer.appendChild(line);
  }, endingMessages.length * 1500 + 2000);
}

// Format numbers
function formatNumber(num) {
  if (typeof num === 'string') return num;
  
  if (num >= 1e33) return (num / 1e33).toFixed(2) + 'D';
  if (num >= 1e30) return (num / 1e30).toFixed(2) + 'N';
  if (num >= 1e27) return (num / 1e27).toFixed(2) + 'O';
  if (num >= 1e24) return (num / 1e24).toFixed(2) + 'S';
  if (num >= 1e21) return (num / 1e21).toFixed(2) + 's';
  if (num >= 1e18) return (num / 1e18).toFixed(2) + 'Q';
  if (num >= 1e15) return (num / 1e15).toFixed(2) + 'q';
  if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
  if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
  if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
  if (num >= 1e4) return (num / 1e4).toFixed(1) + 'k';
  
  return Math.floor(num).toString();
}

// Save indicator
function showSaveIndicator() {
  const indicator = document.getElementById('save-indicator');
  indicator.style.opacity = '1';
  setTimeout(() => {
    indicator.style.opacity = '0';
  }, 2000);
}

// Settings
function openSettings() {
  document.getElementById('settings-modal').style.display = 'flex';
}

function closeSettings() {
  document.getElementById('settings-modal').style.display = 'none';
  saveSettings();
}

function exportSave() {
  const saveData = btoa(JSON.stringify(state));
  const textarea = document.createElement('textarea');
  textarea.value = saveData;
  document.body.appendChild(textarea);
  textarea.select();
  document.execCommand('copy');
  document.body.removeChild(textarea);
  addStory('save exported to clipboard');
}

function importSave() {
  const saveData = prompt('Paste your save data:');
  if (saveData) {
    try {
      const loadedState = JSON.parse(atob(saveData));
      Object.assign(state, loadedState);
      updateDisplay();
      addStory('save imported successfully');
      saveGame();
    } catch (e) {
      addStory('invalid save data');
    }
  }
}

function resetGame() {
  if (confirm('Are you sure you want to reset? This cannot be undone.')) {
    localStorage.removeItem('thinkGameState');
    // Clear URL params and reload
    const baseUrl = window.location.pathname;
    window.location.href = baseUrl + (baseUrl.includes('?') ? '&' : '?') + '_reset=' + Date.now();
  }
}

// Initialize
function init() {
  // Cache DOM elements
  const el = id => document.getElementById(id);
  if (!el('think-button')) {
    console.error('Game elements not found');
    return;
  }
  
  elements['insight-line'] = el('insight-line');
  elements['focus-line'] = el('focus-line');
  elements['wisdom-line'] = el('wisdom-line');
  
  loadSettings();
  loadGame();
  
  // Add initial story if new game
  if (Object.keys(state.storyShown).length === 0) {
    addStory('you are. you think. therefore...');
  }
  
  // Event listeners
  el('think-button').addEventListener('click', (e) => {
    if (state.gameEnded) return;
    if (state.meditationStart) {
      state.meditationStart = null;
      state.meditationBonus = 1;
      addStory('meditation broken');
    }
    const gain = calculateClickPower();
    state.knowledge += gain;
    state.totalClicks++;
    createParticle(e.clientX || 0, e.clientY || 0, `+${formatNumber(gain)}`);
    updateCriticalNumbers();
  });
  
  el('settings-link').addEventListener('click', openSettings);
  el('settings-close').addEventListener('click', closeSettings);
  el('export-save').addEventListener('click', exportSave);
  el('import-save').addEventListener('click', importSave);
  el('reset-game').addEventListener('click', resetGame);
  el('home-link').addEventListener('click', () => window.location.href = 'index.html');
  el('settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'settings-modal') closeSettings();
  });
  
  // Auto-save
  setInterval(() => {
    if (settings.autoSave) {
      saveGame();
      showSaveIndicator();
    }
  }, 30000);
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // Start game loop
  lastFrameTime = 0;
  requestAnimationFrame(gameLoop);
  updateDisplay();
}

// Start when ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>
</body>
</html>
